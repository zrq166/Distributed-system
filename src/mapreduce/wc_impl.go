package mapreduce

import (
	"log"
	"strconv"
	"strings"
	"unicode"
)

// our simplified version of MapReduce does not supply a key to the 
// Map function, as in Google's MapReduce paper; only a value,
// which is a portion of the input file's content
func WCMap(value string) []KeyValue {
	splited_string := strings.FieldsFunc(value, func(r rune) bool {
		if !unicode.IsLetter(r) {
			return true
		}
		return false
	})

	var keyvalue_list []KeyValue
	for index1 := range splited_string {
		var flag int = 0 //no find
		for i, v := range keyvalue_list {
			if splited_string[index1] == v.Key {
				var temp1 int
				temp1, err := strconv.Atoi(v.Value)
				if (err != nil) {
					log.Fatal("string2int:", err)
				}
				v.Value = strconv.Itoa(temp1 + 1)
				keyvalue_list[i] = v
				flag = 1 //find
				break
			}
		}
		if flag == 1 {
			continue
		}
		var temp2 KeyValue
		temp2.Key = splited_string[index1]
		temp2.Value = strconv.Itoa(1)
		keyvalue_list = append(keyvalue_list, temp2)
	}
	return keyvalue_list
}

// called once for each key generated by Map, with a list of that 
// key's values. should return a single output value for that key.
func WCReduce(key string, values []string) string {
	var sum1 int = 0
	var sum1str string
	for num := range values {
		temp1, err := strconv.Atoi(values[num])
		if (err != nil) {
			log.Fatal("string2int:", err)
		}
		sum1=sum1+temp1
	}
	sum1str = strconv.Itoa(sum1)
	return sum1str
}
